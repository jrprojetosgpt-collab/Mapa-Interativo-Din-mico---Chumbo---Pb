<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Mapa Interativo — Isoconcentração de Pb</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    html,body,#map{height:100%;margin:0}
    .legend{position:absolute;bottom:12px;left:12px;background:#fff;border-radius:6px;padding:8px 10px;box-shadow:0 0 10px rgba(0,0,0,.15);font:12px/1.3 Arial,sans-serif}
    .label-min{
      font:12px Arial,sans-serif;font-weight:700;color:#000;
      text-shadow:-1px -1px 0 #fff,0 -1px 0 #fff,1px -1px 0 #fff,
                  -1px 0 0 #fff,1px 0 0 #fff,-1px 1px 0 #fff,0 1px 0 #fff,1px 1px 0 #fff;
    }
    .label-halo{
      font:12px Arial,sans-serif;font-weight:900;color:#000;
      text-shadow:-1px -1px 0 #fff,0 -1px 0 #fff,1px -1px 0 #fff,
                  -1px 0 0 #fff,1px 0 0 #fff,-1px 1px 0 #fff,0 1px 0 #fff,1px 1px 0 #fff;
      white-space:nowrap;
    }
  </style>
</head>
<body>
<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
/* ====== MAPA (com fallback setView) ====== */
/* Coordenadas do seu ponto (aprox.): -29.645642, -51.015153 */
const map = L.map('map', { minZoom:10, maxZoom:22 }).setView([-29.645642, -51.015153], 17);

/* Bases: ESRI (primária) + OSM (fallback automático se a ESRI falhar) */
const osm = L.tileLayer(
  "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
  { attribution:"© OpenStreetMap", maxZoom:22 }
);
const esri = L.tileLayer(
  "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
  { attribution:"Esri, Maxar, Earthstar Geographics", maxZoom:22 }
).on('tileerror', () => { if (!map.hasLayer(osm)) osm.addTo(map); });

esri.addTo(map);

/* ====== RASTERS (PASTAS NA RAIZ DO REPO) ====== */
const raster18 = L.tileLayer("18/{x}/{y}.png", {
  minNativeZoom:18, maxNativeZoom:18, tileSize:256, attribution:"1ª Campanha Pb"
}).addTo(map);

const raster18_ii = L.tileLayer("18_II/18/{x}/{y}.png", {
  minNativeZoom:18, maxNativeZoom:18, tileSize:256, attribution:"2ª Campanha Pb"
}).addTo(map);

const raster18_iii = L.tileLayer("18_III/18/{x}/{y}.png", {
  minNativeZoom:18, maxNativeZoom:18, tileSize:256, attribution:"3ª Campanha Pb"
}).addTo(map);

/* ====== CONTROLE DE CAMADAS ====== */
const baseMaps = {
  "Satélite (Esri)": esri,
  "OSM (fallback)": osm
};
const overlaysInitial = {
  "1ª Campanha Pb": raster18,
  "2ª Campanha Pb": raster18_ii,
  "3ª Campanha Pb": raster18_iii
};
const layerControl = L.control.layers(baseMaps, overlaysInitial, {collapsed:false}).addTo(map);

/* ====== ÁREA DE ESTUDO (fitBounds com tratamento de erro) ====== */
fetch('Area_Estudo_PLUMA.geojson')
  .then(r => {
    if (!r.ok) throw new Error('Area_Estudo_PLUMA.geojson não encontrado');
    return r.json();
  })
  .then(gj => {
    const layer = L.geoJSON(gj, {
      style:{ color:"#0066CC", weight:2, fillColor:"#66B2FF", fillOpacity:0.15 }
    }).addTo(map);
    layerControl.addOverlay(layer, "Área de Estudo");
    map.fitBounds(layer.getBounds());
  })
  .catch(() => {
    // Mantém o setView inicial se o arquivo não existir no repositório
    console.warn('Usando view padrão por ausência de Area_Estudo_PLUMA.geojson');
  });

/* ====== FLECHAS (Dir_Flux_Subt) ====== */
function arrowIcon(angleDeg){
  const svg = `
  <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24">
    <g transform="translate(12,12) rotate(${angleDeg}) translate(-12,-12)">
      <polygon points="12,2 18,10 14,10 14,22 10,22 10,10 6,10" fill="#000"/>
    </g>
  </svg>`;
  return L.divIcon({ html: svg, className:"", iconSize:[22,22], iconAnchor:[11,11] });
}
function resolveAngle(props){
  const fallback = { 1:230, 2:272, 4:170, 5:225, 6:215 };
  const angleFields = ['angulo','angle','rot','rotation','ROT','Ang','ANG','grau','graus','GRAUS'];
  for (const k of angleFields){
    if (props && props[k] != null && !isNaN(Number(props[k]))) return Number(props[k]);
  }
  const id = Number(props?.id ?? props?.ID ?? props?.Id);
  return fallback[id] ?? 0;
}
fetch('Dir_Flux_Subt.geojson')
  .then(r => r.ok ? r.json() : Promise.reject())
  .then(gj => {
    const layer = L.geoJSON(gj, {
      pointToLayer:(f,latlng)=> L.marker(latlng, { icon: arrowIcon(resolveAngle(f.properties)) } ),
      onEachFeature:(f,lyr)=>{
        const ang = resolveAngle(f.properties || {});
        lyr.bindTooltip(`Direção: ${ang.toFixed(0)}°`, { direction:'top', offset:[0,-10], className:'label-min' });
      }
    }).addTo(map);
    layerControl.addOverlay(layer, "Direcionamento do Fluxo Subterrâneo");
  })
  .catch(()=>{ console.warn('Dir_Flux_Subt.geojson ausente'); });

/* ====== CONTORNOS (Isolinhas) ====== */
fetch('Contornos.geojson')
  .then(r => r.ok ? r.json() : Promise.reject())
  .then(gj => {
    const layer = L.geoJSON(gj, {
      style:{ color:"#000", weight:2, fillOpacity:0 },
      onEachFeature:(f, lyr)=>{
        const elev = f.properties && Number(f.properties.ELEV);
        if (!isNaN(elev)) {
          lyr.bindTooltip(`${elev.toFixed(1)}m`, {
            permanent:true, direction:'bottom', offset:[0,9],
            className:'label-min', opacity:1
          });
        }
      }
    }).addTo(map);
    layerControl.addOverlay(layer, "Linhas Equipotenciais (m)");
  })
  .catch(()=>{ console.warn('Contornos.geojson ausente'); });

/* ====== PMS (Poços de Monitoramento) ====== */
function pmIconDiv(){
  const svg = `
    <svg width="18" height="18" viewBox="0 0 18 18" xmlns="http://www.w3.org/2000/svg">
      <circle cx="9" cy="9" r="6.5" fill="#00AEEF" stroke="#000" stroke-width="1.5"/>
      <line x1="9" y1="4" x2="9" y2="14" stroke="#000" stroke-width="1.5"/>
      <line x1="4" y1="9" x2="14" y2="9" stroke="#000" stroke-width="1.5"/>
    </svg>`;
  return L.divIcon({ html: svg, className:"", iconSize:[18,18], iconAnchor:[9,9] });
}
fetch('PMs.geojson')
  .then(r => r.ok ? r.json() : Promise.reject())
  .then(gj => {
    const layer = L.geoJSON(gj, {
      pointToLayer:(f,latlng)=> L.marker(latlng, { icon: pmIconDiv() } ),
      onEachFeature:(f,lyr)=>{
        const props = f.properties || {};
        const nome = (props.Nome ?? props.nome ?? props.NOME ?? "").toString();
        if (nome) lyr.bindTooltip(nome, { permanent:true, direction:"top", offset:[0,-7], opacity:1, className:"label-halo" });
        const rows = Object.entries(props).map(([k,v]) =>
          `<tr><th style="text-align:left;padding-right:8px;">${k}</th><td>${v}</td></tr>`).join("");
        lyr.bindPopup(`<div style="font:12px Arial,sans-serif;"><b>Poços de Monitoramento (PM)</b><br/><table>${rows}</table></div>`);
      }
    }).addTo(map);
    layerControl.addOverlay(layer, "Poços de Monitoramento (PM)");
  })
  .catch(()=>{ console.warn('PMs.geojson ausente'); });
</script>
</body>
</html>








